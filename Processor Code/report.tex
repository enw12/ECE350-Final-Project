\documentclass[letterpaper]{article} % Feel free to change this

\begin{document}

\title{ECE 350: Digital Systems Project Checkpoint 4}
\author{Eric Werbel (enw12)}
\date{March 19, 2019}
\maketitle

\section*{Duke Community Standard}

By submitting this \LaTeX{} document, I affirm that
\begin{enumerate}
    \item I understand that each \texttt{git} commit I create in this repository is a submission
    \item I affirm that each submission complies with the Duke Community Standard and the guidelines set forth for this assignment
    \item I further acknowledge that any content not included in this commit under the version control system cannot be considered as a part of my submission.
    \item Finally, I understand that a submission is considered submitted when it has been pushed to the server.
\end{enumerate}

\section*{Overall Design}
My processor is broken into the typical 5 stages: Fetch (F), Decode (D), Execute (X), Memory (M), and Write (W). In the fetch stage, the program counter acts as the address in the instruction memory where the actual instruction can be found. This stage is very simple, the PC simply gets the instruction from the instruction memory (imem) and stores it in a register for the next stage. The decode stage takes the previously stored instruction and "decodes" it into its components (opcode, rd, rs, etc.). It then stores these values in different registers to be used in the execute stage depending on the specific opcode. For example, some instructions (R type) require data from registers rs and rt, while others (branches) require data from rd and rs. Since there are only two readReg ports, this must be determined in the decode stage so the necessary data can be stored to be used in the execute stage. The execute stage is where the bulk of the actual work happens. Depending on the ALU opcode, different operations (add, subtract, etc.) will be carried out on the data passed into the ALU. This stage is also where jumps are executed, meaning that the PC might not simply be incremented by 1. If a jump is executed, instructions already in the pipeline in the F and D stages must be flushed out. This stage also determines whether or not to branch for branch instructions. The branch is not actually resolved in this stage because by the time the ALU finishes calculating whether the branch should be taken, there is not enough time in the clock cycle to properly update the PC. Due to this, branches are resolved in the memory stage. If a branch is taken, instructions in the F, D, and X stages must all be flushed out of the pipeline. In addition to this, all lw and sw instructions are able to access the data memory (dmem) in this stage. This allows lw instructions to load information out of memory and sw instructions to store data into memory. The last stage in the pipeline is the write stage. In the write stage, data is written to the regFile (if necessary, determined by a write enable). The destination register and data being written are determined by the opcode of the instruction. For example, a jal instruction always writes the current PC+1 to \$r31, while R type instructions usually write the output of the ALU into rd. All control to determine which data should be passed along in the pipeline and written to registers it done through multiplexers and tri-state buffers. 

\subsection*{RegFile}
The register file has a very simple design. It simply consists of 32 different 32-bit registers. Each individual register is made of 32 D flip flops which hold one bit of the 32 bit register. The register file has 2 read ports and 1 write port, meaning that two registers can be read and one register can be written to in the same clock cycle. The readReg and writeReg inputs are sent through a 5 to 32 decoder which will output 32 different wires with only one being set to HIGH. These wires act as the controls on 32 different tri-state buffers for the read register data output ports. The data to be written to a particular register is actually sent to all registers; however, the write enable on each register is also controlled by the outputs of a 5 to 32 decoder ANDed with a general write enable input pin. This allows only one register to be written to at a time. 

\subsection*{ALU}
My ALU has three major sub components: add/subtract, shift, multiply/divide. I decided to put my multdiv inside the ALU and modify the ALUs inputs and outputs to add a dataRDY signal. I did this to consolidate all instructions with an opcode of 0 into one place, instead of having to mux the outputs at the end. No matter what the ALU opcode is, all three sub components are run at every cycle and then tri-state buffers with the 5 to 32 decoded opcode are used to determine which result to pass on as the output of the ALU. I used carry lookahead adders in the add/subtract component of the ALU because I thought they provided the best balance between speed and space requirement. While a carry select adder might have been faster and a normal ripple carry adder might have required less hardware, the carry select adder provided the best balance in my opinion. 

\subsection*{MultDiv}
I separated my multdiv circuit into two separate modules. One for multiplication and one for division. I did this to make it easier for me to follow and because, although they have a lot of similar operations, there are enough difference (especially in sizes of registers) to where I felt it was necessary to have two entirely separate circuits. Within my multiplication circuit, I implemented Booth's Algorithm. I felt that on an average case (not alternating 0s and 1s) this would take less operations to complete  multiplication than a standard naive approach. While it is not as efficient as Modified Booth's Algorithm, the control was much simpler and signals did not take as long to propagate through the control. Since my ALU was barely under the required time limit, saving time wherever I could was a high priority. In my division circuit I used restoring division because it required less space than having separate registers for divisor, dividend and quotient, and it was easier to implement. 

\section*{Implementation}
When implementing instructions, I broke them down into specific types (R-type/addi, lw/sw, jumps, branches). With each type of instruction, I determined what data I needed and whether or not data would need to be written. Using this method, I was able to implement multiple instructions at the same time. For example, I started with the R-type/addi instructions. For these instructions, I needed rs and rt, and needed to store rd through the pipeline to determine the destination register. I added these features to my processor (after having the general 5 stage design implemented) and ran tests using waveforms (explain more later). After getting the R-type instructions working, I started working on the lw/sw instructions. For these instructions I needed rs and rd. To add this functionality, I added a muxs that would alternate whether rt or rd was the second register I would be reading from in the decode stage. The control to this mux was an OR gate of the opcodes that required rd as opposed to rt. This allowed me to only read from two registers at each clock cycle and still have all the necessary information. After this, I went more in-depth on the memory stage. Instead of simply passing the output of the ALU into this stage every time, I had to add a mux deciding whether I should store the output of the ALU or the output of my read from memory in the MW stage. Within the memory stage itself, I simply had to assign different values to different input and output wires to establish the necessary connection with the data memory. To add jumps and branches, I followed the same process. After determining what information I would need, I made sure I had access to the information in each stage of the pipeline where it was required and added controls using muxes. I had to add stall logic to accommodate for the fact that multdiv takes multiple clock cycles to run and flush logic to get rid of instructions previously loaded into the pipeline before a jump or branch was executed. I then worked on adding additional features like hazard detection and bypassing. These features were fairly easy to implement as all of the required data already existed within the pipeline. I simply had to add controls to determine whether or not it was necessary to bypass. This implementation allowed me to check individual instructions as I went to ensure each part of my processor worked correctly. 

To test my processor, I used the Assembler tool provided to generate imem files from MIPS instructions. I then used waveforms, setting the clock high then low multiple times to simulate clock cycles, to test the outputs of my processor. To do this, I had to modify the skeleton file slightly to declare certain wires as outputs in order to access the data in the waveform. I had access to the write register and write data for each register at each clock cycle which allowd me to track what was being stored in the register file at each point through the instructions. Once I figured out how to do this, it made my life a lot easier as I could actually see where my errors were occuring instead of relying on the autograder to give me number and not knowing where the errors were coming from. 

The main challenge for me was figuring out how to combine each part of the processor. Once I had parts of the processor implemented, it was hard for me to figure out effective ways to add more functionality. In the end, I would usually end up declaring a lot of extra wires and adding a mux or tri-state buffer. This realistically should not affect the efficiency of the processor too much as neither option has a particularly large gate delay (especially when compared to adders). However, it felt messy because of the number of new wires I would have to declare each time I added an additional mux to determine what valus to pass through the pipeline. 

\section*{Bugs}
a) lw/sw not working how I thought they would (hard time testing this)\\
b) no stall before bypass logic for RAW hazard after lw \\
c) did not implement bex instruction \\
d) did not update the value of rstatus based on exceptions from the ALU \\  \\
I have 30 minutes so we'll see if I can fix any of these, but I wanted to make sure I got the technical report done!

\end{document}
